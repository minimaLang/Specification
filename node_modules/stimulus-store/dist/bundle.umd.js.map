{"version":3,"file":"bundle.umd.js","sources":["../src/utils/camelize.ts","../src/store/storeValuesTypeMap.ts","../src/store/store.ts","../src/errors/storeErrorHandlers.ts","../src/store/createStore.ts","../src/errors/createStoreErrorHandlers.ts","../src/hooks/useStore.ts","../src/errors/useStoreErrorHandlers.ts","../src/errors/useStoreWarningHandlers.ts"],"sourcesContent":["export function camelize(str: string, firstCharUppercase = false): string {\n  const pattern1: RegExp = /(?:^\\w|[A-Z]|\\b\\w)/g\n  const pattern2: RegExp = /\\s+/g\n  const result: string = str\n    .replace(pattern1, (word, index) =>\n      index === 0 && !firstCharUppercase\n        ? word.toLowerCase()\n        : word.toUpperCase(),\n    )\n    .replace(pattern2, '')\n  return result\n}\n","import type { TypeKey } from '../types/typeKey'\n\n/**\n * A mapping from type names to their corresponding constructor types.\n * - Allows type checking values at runtime.\n * - Allows the use of the following types: String, Number, Array, Object, Boolean.\n * - Each type has its own constructor type: StringConstructor, NumberConstructor, ArrayConstructor, ObjectConstructor, BooleanConstructor.\n * - TypeKey is a union of all the constructor types.\n * @type {Record<string, TypeKey>}\n *\n */\n\nexport const typeMap: Record<string, TypeKey> = {\n  String: String,\n  Number: Number,\n  Array: Array,\n  Object: Object,\n  Boolean: Boolean,\n}\n","import type {\n  CurrentValueCallback,\n  NotifySubscriberOptions,\n  SetOptions,\n  StoreValue,\n  Subscription,\n  TypeKey,\n  UnsubscribeFunction,\n  UpdateMethod,\n} from 'types'\nimport { checkValue, handlePromiseError } from '../errors/storeErrorHandlers'\n/**\n * @template T The type of the value that the store holds.\n * Store Class Explanation:\n *\n * The `Store` class is a versatile class for managing and subscribing to data updates in JavaScript applications.\n * It provides a structured way to store data and notify subscribers when the data changes.\n *\n * Key Features:\n * - Generic Class: Can work with different types of data (specified when creating an instance).\n * - Constructor: Sets the initial value of the store.\n * - `set` Method: Updates the value and notifies subscribers.\n * - `get` Method: Gets the current value.\n * - `subscribe` Method: Subscribes to updates and calls a callback function when data changes.\n * - `unsubscribe` Method: Removes a subscription.\n * - `notifySubscribers` Method: Notifies subscribers when data changes.\n */\n\nexport class Store {\n  readonly name: symbol\n  private value!: StoreValue\n  private initialValue!: StoreValue\n  private subscribers: Set<UpdateMethod>\n  private type: TypeKey\n\n  /**\n   * Creates a new store.\n   *\n   * @param {symbol} name - The name of the store.\n   * @param {TypeKey} type - The type of the store's value.\n   */\n  constructor(name: symbol, type: TypeKey) {\n    this.name = name\n    this.subscribers = new Set()\n    this.type = type\n  }\n\n  /**\n   * Sets the value of the store and notifies subscribers.\n   *\n   * @param {T | CurrentValueCallback | Promise<T | CurrentValueCallback>} newValue - The new value.\n   * @param {SetOptions} [options={ filter: () => true }] - The options for setting the value.\n   */\n  async set(\n    newValue:\n      | StoreValue\n      | CurrentValueCallback\n      | Promise<StoreValue | CurrentValueCallback>,\n    options: SetOptions = { filter: () => true },\n  ) {\n    if (newValue instanceof Promise)\n      return this.resolvePromise(newValue, options)\n    if (newValue === this.get()) return\n    const finalValue: StoreValue =\n      typeof newValue === 'function'\n        ? (newValue as CurrentValueCallback)(this.get())\n        : newValue\n    checkValue(finalValue, this.type)\n    this.setInitialValue(finalValue)\n    this.setValue(finalValue)\n    this.notifySubscribers(options)\n  }\n\n  /**\n   * Gets the current value of the store.\n   *\n   * @returns {StoreValue} The current value.\n   */\n  get(): StoreValue {\n    return this.value\n  }\n\n  /**\n   * Resets the store to its initial value.\n   */\n  resetValue(): void {\n    this.setValue(this.initialValue)\n  }\n\n  private setValue(value: StoreValue): void {\n    this.value = value\n  }\n\n  private setInitialValue(value: StoreValue): void {\n    if (this.value === undefined) this.initialValue = value\n  }\n\n  /**\n   * Subscribes to the store.\n   *\n   * @param {UpdateMethod} callback - The function to call when the store's value changes.\n   * @returns {UnsubscribeFunction} A function that unsubscribes the callback.\n   */\n  private subscribe(callback: UpdateMethod): UnsubscribeFunction {\n    this.subscribers.add(callback)\n    callback(this.get()) // Immediate call for initial value\n    return () => this.unsubscribe(callback) // Return an unsubscribe function\n  }\n\n  /**\n   * Unsubscribes from the store.\n   *\n   * @param {UpdateMethod} callback - The function to unsubscribe.\n   */\n  private unsubscribe(callback: UpdateMethod) {\n    this.subscribers.delete(callback)\n  }\n\n  /**\n   * Gets a subscription object with subscribe, when invoked subscribe returns an unsubscribe function.\n   *\n   * @returns {Subscription} A subscription object.\n   */\n  public getSubscription(): Subscription {\n    return {\n      subscribe: (callback: UpdateMethod) => this.subscribe(callback),\n    }\n  }\n\n  private notifySubscribers(options: NotifySubscriberOptions) {\n    Array.from(this.subscribers)\n      .filter(() => options.filter(this.get()))\n      .forEach((callback) => callback(this.get()))\n  }\n\n  private async resolvePromise(\n    newValue: Promise<StoreValue | CurrentValueCallback>,\n    options: SetOptions,\n  ) {\n    try {\n      const resolvedValue = await newValue\n      this.set(resolvedValue, options)\n    } catch (error) {\n      handlePromiseError(error)\n    }\n  }\n}\n","/**\n * Checks if the value is of the specified type.\n * @param {unknown} value - The value to check.\n * @param {new (...args: unknown[]) => unknown} type - The type constructor for the expected type.\n * @throws {Error} If the value is not of the expected type.\n */\nexport function checkValue(\n  value: unknown,\n  type: new (...args: unknown[]) => unknown,\n): void {\n  if (Object.getPrototypeOf(value).constructor !== type) {\n    throw new Error(`Value '${value}' must be of type ${type.name}`)\n  }\n}\n\n/**\n * Handles errors that occur when a promise fails to resolve.\n * @param {unknown} error - The error that occurred.\n * @throws {Error} A new error with a message indicating that the promise failed to resolve.\n */\nexport function handlePromiseError(error: unknown): never {\n  throw new Error(`Failed to resolve promise:\\n${error}`)\n}\n","import {\n  checkInitialValue,\n  checkName,\n  checkTypeConstructor,\n  handleStoreSetError,\n} from '../errors/createStoreErrorHandlers'\nimport type { StoreOptions } from '../types/storeOptions'\nimport type { StoreValue } from '../types/storeValue'\nimport type { TypeKey } from '../types/typeKey'\nimport { Store } from './store'\n\n/**\n * The createStore function is a factory function that creates and returns a new instance of the Store class.\n * It takes an options object as a parameter, which should include the name, initialValue, and type for the new store.\n *\n * Here's a technical breakdown of how it works:\n * - The function destructure's the name, type, and initialValue properties from the options object.\n * - It checks if initialValue is undefined. If it is, the function throws an error because a store must be initialized with a value.\n * - It checks if name is not a string. If it isn't, the function throws an error because the store's name must be a string. This name is used to create a unique Symbol which serves as the identifier for the store.\n * - It creates a new Symbol using the name and assigns it to symbolName.\n * - It creates a new instance of the Store class, passing symbolName, initialValue, and type to the Store constructor, and returns this new instance.\n *\n * The Store class encapsulates the state (the initialValue) and provides methods to get and set that state. The type is used for type checking to ensure that the store's value always matches the expected type.\n *\n * Usage Example:\n * ```javascript\n * const countStore = createStore({ name: 'count', initialValue: 0, type: Number });\n * ```\n *\n * @param {StoreOptions<T>} options - The options for the store.\n * @param {string} options.name - The name of the store. This will be used to create a unique Symbol.\n * @param {T} options.initialValue - The initial value of the store. This must be provided.\n * @param {TypeKey} options.type - The type of the store's value. This is used for type checking [String, Number, Boolean, Array, Object].\n *\n * @returns {Store<T>} The new store.\n *\n * @throws {Error} If no initial value is provided.\n * @throws {Error} If the name is not a string.\n */\n\nexport function createStore(options: StoreOptions): Store {\n  const name: string = options.name\n  const type: TypeKey = options.type\n  const initialValue: StoreValue = options.initialValue\n  checkInitialValue(initialValue)\n  checkName(name)\n  checkTypeConstructor(type.name)\n  const symbolName = Symbol(name)\n\n  const store: Store = new Store(symbolName, type)\n  store.set(initialValue).catch((error) => handleStoreSetError(error))\n  return store\n}\n","import { typeMap } from '../store/storeValuesTypeMap'\n\n/**\n * Checks if the initial value is defined.\n * @param {T} initialValue - The initial value of the store.\n * @throws {Error} If the initial value is undefined.\n */\nexport function checkInitialValue<T>(initialValue: T): void {\n  if (typeof initialValue === 'undefined') {\n    throw new Error('Store must be initialized with a value')\n  }\n}\n\n/**\n * Checks if the store name is a string.\n * @param {string} name - The name of the store.\n * @throws {Error} If the store name is not a string.\n */\nexport function checkName(name: string): void {\n  if (typeof name !== 'string') {\n    throw new Error('Store name must be of Type string')\n  }\n}\n\n/**\n * Checks if the type constructor exists in the type map.\n * @param {string} type - The type of the store value.\n * @throws {Error} If the type constructor does not exist in the type map.\n */\nexport function checkTypeConstructor(type: string): void {\n  const typeConstructor = typeMap[type]\n  if (typeof typeConstructor !== 'function') {\n    throw new Error(`Invalid type: ${type}`)\n  }\n}\n\n/**\n * Handles errors that occur when setting the store value.\n * @param {unknown} error - The error that occurred.\n * @throws {Error} A new error with the same message if the original error is an instance of Error.\n * @throws {Error} A new error with a generic message if the original error is not an instance of Error.\n */\nexport function handleStoreSetError(error: unknown): never {\n  if (error instanceof Error) {\n    throw new Error(`Failed to create store: ${error.message}`)\n  }\n  throw new Error('An unknown error occurred while creating the store')\n}\n","import type { StoreController, StoreValue, Subscription } from 'types'\nimport { checkStores } from '../errors/useStoreErrorHandlers'\nimport { warnDirectAccess } from '../errors/useStoreWarningHandlers'\nimport type { Store } from '../store/store'\nimport { camelize } from '../utils/camelize'\n/**\n * useStore Function\n * The useStore function simplifies the process of subscribing to and handling updates from multiple store instances\n * within a Stimulus controller. It also allows direct access to store values on the controller.\n * How It Works:\n * 1. Retrieves the stores from the controller's constructor.\n * 2. Iterates over the stores.\n * 3. Identifies the type of each store and constructs an update method name.\n * 4. Creates update methods for stores if corresponding onStoreUpdate methods exist on the controller.\n * 5. Dynamically assigns update methods to the controller with specific names based on store types.\n * 6. Subscribes update methods to stores to handle updates.\n * 7. Allows direct access to store values on the controller.\n * 8. Enhances the controller's disconnect method to include cleanup for all subscriptions.\n *\n * Usage Example:\n * ```javascript\n * import { Controller } from \"@hotwired/stimulus\";\n * import { useStore } from \"stimulus-store\";\n * import { myStore } from \"./stores/myStore\"; // Import your store class\n *\n * export default class extends Controller {\n *  static stores = [myStore];\n *\n *   connect() {\n *     // Use the useStore function to subscribe to specific stores\n *     useStore(this);\n *   }\n *\n *   // Implement specific update methods for each store\n *   onMyStoreUpdate() {\n *     // Handle updates for MyStore\n *     console.log(\"MyStore updated:\", this.myStoreValue);\n *   }\n * }\n * ```\n * @param {Object} controller - The Stimulus controller instance that wants to subscribe to the stores.\n * @template T - The type of data stored in the stores.\n */\n\nexport function useStore(controller: StoreController) {\n  const stores: Store[] | undefined = controller.constructor?.stores\n  const unsubscribeFunctions: (() => void)[] = []\n\n  // If 'stores' is undefined or empty, throw an error\n  checkStores(stores)\n\n  stores?.forEach((store) => {\n    const storeName: symbol = store.name\n    const storeNameAsString: string = storeName.toString().slice(7, -1)\n    const camelizedName: string = camelize(storeNameAsString)\n    const onStoreUpdateMethodName: string = `on${camelize(\n      storeNameAsString,\n      true,\n    )}Update`\n    const onStoreUpdateMethod = controller[onStoreUpdateMethodName] as (\n      value: StoreValue,\n    ) => void\n    const subscription: Subscription = store.getSubscription()\n\n    if (onStoreUpdateMethod) {\n      const updateMethod: (value: StoreValue) => void = (value) => {\n        onStoreUpdateMethod.call(controller, value)\n      }\n\n      const methodName = `update${camelize(storeNameAsString, true)}`\n      controller[methodName] = updateMethod\n\n      unsubscribeFunctions.push(subscription.subscribe(updateMethod))\n    }\n\n    // Add a helper method to set the store value\n    const setStoreValueMethodName = `set${camelize(\n      storeNameAsString,\n      true,\n    )}Value`\n    controller[setStoreValueMethodName] = (\n      value:\n        | StoreValue\n        | Promise<StoreValue>\n        | ((prev: StoreValue) => StoreValue),\n    ) => {\n      store.set(value)\n    }\n\n    // Add a helper method to reset the store value\n    const resetStoreMethodName = `reset${camelize(storeNameAsString, true)}`\n    controller[resetStoreMethodName] = () => {\n      store.resetValue()\n    }\n\n    const storeGetterMethodName: string = `${camelizedName}Value`\n\n    Object.defineProperty(controller, storeGetterMethodName, {\n      get: () => store.get(),\n      enumerable: true,\n      configurable: true,\n    })\n\n    let isWarned = false\n\n    // Wrap the store in a Proxy to intercept direct access\n    const storeProxy = new Proxy(store, {\n      get: (target, prop, receiver) => {\n        isWarned = warnDirectAccess(camelizedName, isWarned)\n        return Reflect.get(target, prop, receiver)\n      },\n    })\n\n    Object.defineProperty(controller, camelizedName, {\n      get: () => storeProxy,\n      enumerable: true,\n      configurable: true,\n    })\n  })\n\n  const originalDisconnect = controller.disconnect.bind(controller)\n  controller.disconnect = () => {\n    unsubscribeFunctions.forEach((unsubscribe) => {\n      if (unsubscribe) {\n        unsubscribe()\n      }\n    })\n    originalDisconnect()\n  }\n}\n","/**\n * Checks if the stores array is defined, not empty, and is an array.\n * @param {unknown} stores - The stores array to check.\n * @throws {Error} If the stores array is undefined, empty, or not an array.\n */\nexport function checkStores(stores: unknown): void {\n  if (!stores) {\n    throw new Error(\n      `'useStore' was called on a controller without a 'stores' static property. The 'stores' property is undefined.`,\n    )\n  }\n\n  if (!Array.isArray(stores)) {\n    throw new Error(\n      `'useStore' was called on a controller with a 'stores' static property that is not an array.`,\n    )\n  }\n\n  if (stores.length === 0) {\n    throw new Error(\n      `'useStore' was called on a controller with an empty 'stores' static property. The 'stores' array should contain at least one store.`,\n    )\n  }\n}\n","/**\n * Logs a warning message if the store is accessed directly and `isWarned` is false.\n * @param {string} camelizedName - The camelized name of the store.\n * @param {boolean} isWarned - A flag indicating if the warning has already been logged.\n * @returns {boolean} Returns true if the warning was logged, otherwise returns the original `isWarned` value.\n */\nexport function warnDirectAccess(\n  camelizedName: string,\n  isWarned: boolean,\n): boolean {\n  if (!isWarned) {\n    console.warn(\n      `Warning: You are accessing the '${camelizedName}' instance directly. Consider using 'on${\n        camelizedName.charAt(0).toUpperCase() + camelizedName.slice(1)\n      }Update' and '${camelizedName}Value' instead.`,\n    )\n    return true\n  }\n  return isWarned\n}\n"],"names":["camelize","str","firstCharUppercase","replace","word","index","toUpperCase","toLowerCase","typeMap","String","Number","Array","Object","Boolean","Store","constructor","name","type","this","subscribers","Set","set","newValue","options","filter","Promise","resolvePromise","get","finalValue","value","getPrototypeOf","Error","checkValue","setInitialValue","setValue","notifySubscribers","resetValue","initialValue","undefined","subscribe","callback","add","unsubscribe","delete","getSubscription","from","forEach","resolvedValue","error","handlePromiseError","checkInitialValue","checkName","checkTypeConstructor","symbolName","Symbol","store","catch","message","handleStoreSetError","controller","stores","unsubscribeFunctions","isArray","length","checkStores","storeNameAsString","toString","slice","camelizedName","onStoreUpdateMethodName","onStoreUpdateMethod","subscription","updateMethod","call","methodName","push","setStoreValueMethodName","resetStoreMethodName","storeGetterMethodName","defineProperty","enumerable","configurable","isWarned","storeProxy","Proxy","target","prop","receiver","warnDirectAccess","Reflect","originalDisconnect","disconnect","bind"],"mappings":"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"}